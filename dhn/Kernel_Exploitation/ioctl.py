#!/usr/bin/env python
"""
 Decodes 32-Bit Windows Device I/O control codes.

 This script based on "Windows Driver Plugin" IDA Pro plugin::
  - https://github.com/mwrlabs/z3_and_angr_binary_analysis_workshop/ (Sam Brown)
  - https://github.com/mwrlabs/win_driver_plugin (Sam Brown)
  - https://github.com/tandasat/WinIoCtlDecoder/blob/master/plugins/WinIoCtlDecoder.py (Satoshi Tanda)
"""

import os
import re
import sys
import angr
import mmap
import pyvex 
import claripy
import logging
import argparse
import collections


class IOCTL:
	def __init__(self, driver):
		self._ASCII_BYTE = b" !\"#\$%&\'\(\)\*\+,-\./0123456789:;<=>\?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]\^_`abcdefghijklmnopqrstuvwxyz\{\|\}\\\~\t"
		self._UNICODE_RE_4 = re.compile(b"((?:[%s]\x00){%d,})" % (self._ASCII_BYTE, 4))
		self._REPEATS = ["A", "\x00", "\xfe", "\xff"] 
		self._String = collections.namedtuple("String", ["s", "offset"])

		self._driver = driver
		self._p = angr.Project(self._driver, auto_load_libs=False)

	def __get_device(self, ioctl_code):
		""" Returns the correct device name for a 32 bit IOCTL code """

		device_name_unknown = "<UNKNOWN>"
		device_names = [
			device_name_unknown,                # 0x00000000
			"FILE_DEVICE_BEEP",                 # 0x00000001
			"FILE_DEVICE_CD_ROM",               # 0x00000002
			"FILE_DEVICE_CD_ROM_FILE_SYSTEM",   # 0x00000003
			"FILE_DEVICE_CONTROLLER",           # 0x00000004
			"FILE_DEVICE_DATALINK",             # 0x00000005
			"FILE_DEVICE_DFS",                  # 0x00000006
			"FILE_DEVICE_DISK",                 # 0x00000007
			"FILE_DEVICE_DISK_FILE_SYSTEM",     # 0x00000008
			"FILE_DEVICE_FILE_SYSTEM",          # 0x00000009
			"FILE_DEVICE_INPORT_PORT",          # 0x0000000a
			"FILE_DEVICE_KEYBOARD",             # 0x0000000b
			"FILE_DEVICE_MAILSLOT",             # 0x0000000c
			"FILE_DEVICE_MIDI_IN",              # 0x0000000d
			"FILE_DEVICE_MIDI_OUT",             # 0x0000000e
			"FILE_DEVICE_MOUSE",                # 0x0000000f
			"FILE_DEVICE_MULTI_UNC_PROVIDER",   # 0x00000010
			"FILE_DEVICE_NAMED_PIPE",           # 0x00000011
			"FILE_DEVICE_NETWORK",              # 0x00000012
			"FILE_DEVICE_NETWORK_BROWSER",      # 0x00000013
			"FILE_DEVICE_NETWORK_FILE_SYSTEM",  # 0x00000014
			"FILE_DEVICE_NULL",                 # 0x00000015
			"FILE_DEVICE_PARALLEL_PORT",        # 0x00000016
			"FILE_DEVICE_PHYSICAL_NETCARD",     # 0x00000017
			"FILE_DEVICE_PRINTER",              # 0x00000018
			"FILE_DEVICE_SCANNER",              # 0x00000019
			"FILE_DEVICE_SERIAL_MOUSE_PORT",    # 0x0000001a
			"FILE_DEVICE_SERIAL_PORT",          # 0x0000001b
			"FILE_DEVICE_SCREEN",               # 0x0000001c
			"FILE_DEVICE_SOUND",                # 0x0000001d
			"FILE_DEVICE_STREAMS",              # 0x0000001e
			"FILE_DEVICE_TAPE",                 # 0x0000001f
			"FILE_DEVICE_TAPE_FILE_SYSTEM",     # 0x00000020
			"FILE_DEVICE_TRANSPORT",            # 0x00000021
			"FILE_DEVICE_UNKNOWN",              # 0x00000022
			"FILE_DEVICE_VIDEO",                # 0x00000023
			"FILE_DEVICE_VIRTUAL_DISK",         # 0x00000024
			"FILE_DEVICE_WAVE_IN",              # 0x00000025
			"FILE_DEVICE_WAVE_OUT",             # 0x00000026
			"FILE_DEVICE_8042_PORT",            # 0x00000027
			"FILE_DEVICE_NETWORK_REDIRECTOR",   # 0x00000028
			"FILE_DEVICE_BATTERY",              # 0x00000029
			"FILE_DEVICE_BUS_EXTENDER",         # 0x0000002a
			"FILE_DEVICE_MODEM",                # 0x0000002b
			"FILE_DEVICE_VDM",                  # 0x0000002c
			"FILE_DEVICE_MASS_STORAGE",         # 0x0000002d
			"FILE_DEVICE_SMB",                  # 0x0000002e
			"FILE_DEVICE_KS",                   # 0x0000002f
			"FILE_DEVICE_CHANGER",              # 0x00000030
			"FILE_DEVICE_SMARTCARD",            # 0x00000031
			"FILE_DEVICE_ACPI",                 # 0x00000032
			"FILE_DEVICE_DVD",                  # 0x00000033
			"FILE_DEVICE_FULLSCREEN_VIDEO",     # 0x00000034
			"FILE_DEVICE_DFS_FILE_SYSTEM",      # 0x00000035
			"FILE_DEVICE_DFS_VOLUME",           # 0x00000036
			"FILE_DEVICE_SERENUM",              # 0x00000037
			"FILE_DEVICE_TERMSRV",              # 0x00000038
			"FILE_DEVICE_KSEC",                 # 0x00000039
			"FILE_DEVICE_FIPS",                 # 0x0000003A
			"FILE_DEVICE_INFINIBAND",           # 0x0000003B
			device_name_unknown,                # 0x0000003C
			device_name_unknown,                # 0x0000003D
			"FILE_DEVICE_VMBUS",                # 0x0000003E
			"FILE_DEVICE_CRYPT_PROVIDER",       # 0x0000003F
			"FILE_DEVICE_WPD",                  # 0x00000040
			"FILE_DEVICE_BLUETOOTH",            # 0x00000041
			"FILE_DEVICE_MT_COMPOSITE",         # 0x00000042
			"FILE_DEVICE_MT_TRANSPORT",         # 0x00000043
			"FILE_DEVICE_BIOMETRIC",            # 0x00000044
			"FILE_DEVICE_PMI",                  # 0x00000045
		]
		device_names2 = [
			{"name": "MOUNTMGRCONTROLTYPE", "code": 0x0000006d},
		]

		device = (ioctl_code >> 16) & 0xffff
		if device >= len(device_names):
			device_name = device_name_unknown
			for dev in device_names2:
				if device == dev["code"]:
					device_name = dev["name"]
					break
		else:
			device_name = device_names[device]
		return device_name, device

	def __get_method(self, ioctl_code):
		""" Returns the correct method type name for a 32 bit IOCTL code """
		
		method_names = [
			"METHOD_BUFFERED",
			"METHOD_IN_DIRECT",
			"METHOD_OUT_DIRECT",
			"METHOD_NEITHER",
		]
		method = ioctl_code & 3
		return method_names[method], method

	def __get_access(self, ioctl_code):
		""" Returns the correct access type name for a 32 bit IOCTL code """

		access_names = [
			"FILE_ANY_ACCESS",
			"FILE_READ_ACCESS",
			"FILE_WRITE_ACCESS",
			"FILE_READ_ACCESS | FILE_WRITE_ACCESS",
		]
		access = (ioctl_code >> 14) & 3
		return access_names[access], access

	def __get_function(self, ioctl_code):
		""" Calculates the function code from a 32 bit IOCTL code """

		return (ioctl_code >> 2) & 0xfff

	def __find_dispatch(self):
		""" Attempts to find the drivers dispatch function by analysing it's lifted code """

		cfg = self._p.analyses.CFGEmulated()

		all_vex = [self._p.factory.block(i.addr).vex for i in cfg.nodes()]
		dispatch_addr = None
		const_seen = False
		for vex in all_vex:
			for stmt in vex.statements:
				const = stmt.constants
				if len(const) > 0:
					if const[0].value == 0x70:
						const_seen = True
				if isinstance(stmt, pyvex.IRStmt.IMark):
					const_seen = False
				if isinstance(stmt, pyvex.IRStmt.Store) and const_seen:
					store_consts = stmt.constants
					if len(store_consts) > 0:
						dispatch_addr = store_consts[0].value
						break
		if not dispatch_addr:
			print("[-] Could not find IOCTL dispatch function :(")
		else:
			print("[+] Dispatch function found: {:#x}".format(dispatch_addr))
		return dispatch_addr

	def __extract_unicode_strings(self, buf, n=4):
		""" Extract naive UTF-16 strings from the given binary data """

		if not buf:
			return

		if (buf[0] in self._REPEATS) and buf_filled_with(buf, buf[0]):
			return

		if n == 4:
			r = self._UNICODE_RE_4
		else:
			reg = b"((?:[%s]\x00){%d,})" % (self._ASCII_BYTE, n)
			r = re.compile(reg)
		for match in r.finditer(buf):
			try:
				yield self._String(match.group().decode("utf-16"), match.start())
			except UnicodeDecodeError:
				pass

	def __get_unicode_device_names(self):
		""" Returns all Unicode strings within the binary """

		min_length = 4
		possible_names = set()
		with open(self._driver, "rb") as f:
			b = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)

			for s in self.__extract_unicode_strings(b, n=min_length):
				s_str = str(s.s)
				if s_str.startswith('\\Device\\'):
					possible_names.add(str(s.s))
		return possible_names

	def find_unicode_device_name(self):
		""" Attempts to find and output potential device names - returning False if none are found so further analysis can be done"""

		possible_names = self.__get_unicode_device_names()
		if len(possible_names) == 1 or len(possible_names) == 2:
			if '\\Device\\' in possible_names:
				if len(possible_names) == 1:
					return False
				elif '\\Device\\' in possible_names:
					return False
				else:
					print("Potential device name: ")
					for i in possible_names:
						if i != '\\Device\\':
							print("[+] Device name: {:s}".format(i))
				return True
			else:
				for i in possible_names:
					print("[+] Device name: {:s}".format(i))
				return True
		elif len(possible_names) > 2:
			print("[+] Device names:")
			for i in possible_names:
				print("\t" + i)
			return True
		else:
			return False

	def find_ioctls(self):
		""" Returns a list of potential IOCTL codes by symbolically executing starting at the provided function address """

		dispatch_addr = self.__find_dispatch()
		s = self._p.factory.blank_state(addr=dispatch_addr)
		pg = self._p.factory.simulation_manager(s)

		# Ranges the image has been mapped into memory by angr
		min_image_addr = self._p.loader.main_object.min_addr
		max_image_addr = self._p.loader.main_object.max_addr

		default_regs = ["eax", "ecx", "edx", "ebx", "esi", "edi"]

		generic_reg_vals = set()
		val_addr = {}
		steps = 0
		while len(pg.active) > 0 and steps < 25:
			for i in pg.active:
				# Skip bad addresses
				if i.addr < min_image_addr or i.addr > max_image_addr:
					continue
				for reg in default_regs:
					try:
						val = i.solver.eval(getattr(i.regs, reg))
						generic_reg_vals.add(val)
						if val not in val_addr:
							val_addr[val] = i.addr
					except angr.errors.SimUnsatError:
						print("[-] Failed to get {}".format(reg))
					except claripy.errors.ClaripyZeroDivisionError:
						print("[-] Failed to get {}".format(reg))
			pg.step()
			steps += 1
		device_codes = {}

		generic_reg_vals = list(filter(lambda x: 0xfff0 > ((x >> 16) & 0xffff) > 0x10, generic_reg_vals))
		for i in generic_reg_vals:
			try:
				device_codes[((i >> 16) & 0xffff)] += 1
			except KeyError:
				device_codes[((i >> 16) & 0xffff)] = 1

		if len(device_codes.keys()) == 0:
			return []

		likely_device_code = max(device_codes, key=device_codes.get)

		out = []
		for i in generic_reg_vals:
			addr = val_addr[i]
			if (i >> 16) & 0xffff == likely_device_code:
				out.append((addr, i))
		return out

	def print_table(self, ioctls):
		if len(ioctls) != 0:
			print("{:10s} | {:10s} | {:32s} | {:10s} | {:22s} | {:s}".format("Address", "IOCTL Code", "Device", "Function", "Method", "Access"))
			print("{:s}+{:s}+{:s}+{:s}+{:s}+{:s}".format("-" * 11, "-" * 12, "-" * 34, "-" * 12, "-" * 24, "-" * 22))

			for (addr, ioctl_code) in ioctls:
				function = self.__get_function(ioctl_code)
				device_name, device_code = self.__get_device(ioctl_code)
				method_name, method_code = self.__get_method(ioctl_code)
				access_name, access_code = self.__get_access(ioctl_code)
				all_vars = (addr, ioctl_code, device_name, device_code, function, method_name, method_code, access_name, access_code)
				print("0x%-8X | 0x%-8X | %-21s 0x%-8X | 0x%-8X | %-17s %-4d | %s (%d)" % all_vars)

def run(args):
	logging.basicConfig() # Remove angr WARNING output
	logging.getLogger("").setLevel(logging.ERROR) 

	ioctl = IOCTL(args.file)
	ioctl.find_unicode_device_name()

	ioctls = ioctl.find_ioctls()
	ioctl.print_table(ioctls)

if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("-f","--file", help="Path to driver (*.sys)",
						required=True)
	args = parser.parse_args()

	run(args)
